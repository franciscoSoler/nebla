/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "numeradorClientes.h"

#include "commonNumerador.h"

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <unistd.h>
#include <errno.h>

int semaphoreId = 0;
int shMemId = 0;
void* data = NULL;

void initIPC();
void writeInfo(ClientesInfo* dato);

/* Shared Memory */
int getSharedMemory(char *fileName, int id);
int getShMemId(char *fileName, int id, int flags);
int attachMemory();

/* Semaphore */
int getSemaphoreId(char *fileName, int id, int qty, int flags);
int getSemaphore(char *fileName, int id, int qty);
int wait(int numSem);
int signal(int numSem);

retorno *
obteneridcliente_1_svc(void *argp, struct svc_req *rqstp)
{
	static retorno  result;

        ClientesInfo* numeradorInfo;
	int numero = 0;		
	char exito = 0;
	int i = 0;

	initIPC();
	printf("Intentando obtener un cliente libre.\n");

	wait(0);
	{
		numeradorInfo = (ClientesInfo*)data;
		while ((exito == 0) && (i < MAX_CLIENTES)) {
			printf("Verificando cliente numero: %d: %d.\n",i+1, numeradorInfo->idClientes[i]);
			if (numeradorInfo->idClientes[i] == 0) {
				printf("Cliente libre: %d.\n",i+1);
				numero = i+1;
				exito = 1;
				numeradorInfo->idClientes[i] = 1;
			}
			++i;
		}
		if (exito == 1) {
			writeInfo(numeradorInfo);
		}
	}
	signal(0);

	result.retorno_u.numero = numero;	
	if (exito == 1) {
		result.cod_ret = 1;
		printf("Cliente libre obtenido: %d.\n", numero);
	}
	else {
		result.cod_ret = 2;
		printf("No hay clientes libres disponibles.\n");
	}
        
	return &result;
}

void *
devolveridcliente_1_svc(int *argp, struct svc_req *rqstp)
{
	static char * result;

	ClientesInfo* numeradorInfo;

	printf("Devolviendo el cliente: %d.\n", (*argp));
	initIPC();
	wait(0);
	{
		numeradorInfo = (ClientesInfo*)data;
		numeradorInfo->idClientes[(*argp)-1] = 0;
		writeInfo(numeradorInfo);
	}		
	signal(0);

	return (void *) &result;
}

void *
resetearclientes_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;

	ClientesInfo* numeradorInfo;
	int i;

	printf("Reseteando clientes...\n");
	initIPC();
	wait(0);
	{
		numeradorInfo = (ClientesInfo*)data;
		for (i = 0; i < MAX_CLIENTES; ++i) {
			numeradorInfo->idClientes[i] = 0;
		}

		writeInfo(numeradorInfo);

	}		
	signal(0);

	return (void *) &result;
}

retorno *
listadoclientes_1_svc(void *argp, struct svc_req *rqstp)
{
	static retorno  result;

	ClientesInfo* numeradorInfo;
	initIPC();
	wait(0);
	{
		numeradorInfo = (ClientesInfo*)data;
		memcpy(result.retorno_u.informacion,numeradorInfo->idClientes,MAX_CLIENTES);
	}		
	signal(0);

	result.cod_ret = 1;
	return &result;
}

/* IPC */

void initIPC() {
	if (data == NULL) getSharedMemory(DIRECTORY_NUMERADOR_CLIENTES, ID_NUMERADOR_CLIENTES);
	if (semaphoreId == 0) getSemaphore(DIRECTORY_NUMERADOR_CLIENTES, ID_NUMERADOR_CLIENTES, 1);
}

/* Shared Memory Methods */

int getSharedMemory(char *fileName, int id) {
	int result = getShMemId(fileName, id, 0666);
	if (result < 0) return -1;
	return attachMemory();
}

int getShMemId(char *fileName, int id, int flags) {
	char buffer[255];
	key_t clave = ftok (fileName, id);
	if ( clave == -1 ) {
		strcpy(buffer, "Error en SharedMemory - ftok:");
		strcat(buffer, strerror(errno));	
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}

	shMemId = shmget( clave, sizeof(ClientesInfo) , flags);
	if ( id == -1 ) {
		strcpy(buffer, "Error en SharedMemory - shmget:");
		strcat(buffer, strerror(errno));
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}
	return 0;
}

int attachMemory() {
	/* Me attacho a la memoria dejando al SO que elija donde ubicar la memoria 
	 * (atributo en NULL)y para lectura/escritura (atributo en 0) */
	char buffer[255];
	void *shmaddr = shmat(shMemId, (void *)NULL, 0);
	if (shmaddr == (void *)-1) {
		strcpy(buffer, "Error en Shared Memory - shmat:");
		strcat(buffer, strerror(errno));
		strcat(buffer, "\n");	
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}
	data = shmaddr;
	return 0;
}

void writeInfo(ClientesInfo* dato) {
	/* CUIDADO
	 * data = direccion de memoria compartida
	 * dato = dato a guardar en la memoria compartida */
        ClientesInfo *dir = (ClientesInfo*)data;
        memcpy(dir, dato, sizeof(ClientesInfo));
}

/* Semaphore Methods */

int getSemaphore(char *fileName, int id, int qty) {
	int result = getSemaphoreId(fileName, id, qty, 0666);
	return result;
}

int getSemaphoreId(char *fileName, int id, int qty, int flags) { 
	char buffer[255];
	key_t clave = ftok (fileName, id);
	if ( clave == -1 ) {
		strcpy(buffer, "Error en Semaphore - ftok:");
		strcat(buffer, strerror(errno));	
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}

	semaphoreId =  semget( clave, qty, flags);
	if ( semaphoreId == -1 ) {
		strcpy(buffer, "Error en Semaphore - semget:");
		strcat(buffer, strerror(errno));
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}
	return 0;
}

int wait(int numSem) {	
	struct sembuf oper;
	oper.sem_num = numSem;
	oper.sem_op = -1;
        oper.sem_flg = 0;
	return (semop(semaphoreId, &oper, 1));
}

int signal(int numSem) {
	struct sembuf oper;
	oper.sem_num = numSem;
	oper.sem_op = 1;
	oper.sem_flg = 0;
	return (semop(semaphoreId, &oper, 1));
}

