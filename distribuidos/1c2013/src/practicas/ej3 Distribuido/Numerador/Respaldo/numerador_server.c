/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "numerador.h"

#include "commonNumerador.h"

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <unistd.h>
#include <errno.h>

int semaphoreId = 0;
int shMemId = 0;
void* data = NULL;

void initIPC();
void writeInfo(NumeradorInfo* dato);

retorno *
numeradorcliente_2_svc(void *argp, struct svc_req *rqstp)
{
	printf("Intentando obtener un cliente libre.\n");
	static retorno  result;

	initIPC();
		
	NumeradorInfo* numeradorInfo;
	int numero = 0;		
	char exito = 0;

	wait(0);
	{
		numeradorInfo = (NumeradorInfo*)data;
		int i = 0;
		while ((exito == 0) && (i < MAX_CLIENTES)) {
			printf("Verificando cliente numero: %d: %d.\n",i+1, numeradorInfo->numerosClientes[i]);
			if (numeradorInfo->numerosClientes[i] == 0) {
				printf("Cliente libre: %d.\n",i+1);
				numero = i+1;
				exito = 1;
				numeradorInfo->numerosClientes[i] = 1;
			}
			++i;
		}
		if (exito == 1) {
			writeInfo(numeradorInfo);
		}
	}
	signal(0);

	result.retorno_u.numero = numero;	
	if (exito == 1) {
		result.cod_ret = 1;
		printf("Cliente libre obtenido: %d.\n", numero);
	}
	else {
		result.cod_ret = 2;
		printf("No hay clientes libres disponibles.\n");
	}
	
	return &result;
}

retorno *
numeradorvendedor_2_svc(void *argp, struct svc_req *rqstp)
{
	printf("Intentando obtener un vendedor libre.\n");
	static retorno  result;

	initIPC();
	
	NumeradorInfo* numeradorInfo;
	int numero = 0;		
	char exito = 0;

	wait(0);
	{
		numeradorInfo = (NumeradorInfo*)data;
		int i = 0;
		while ((exito == 0) && (i < MAX_VENDEDORES)) {
			if (numeradorInfo->numerosVendedores[i] == 0) {
				numero = i+1;
				exito = 1;
				numeradorInfo->numerosVendedores[i] = 1;
			}
			++i;
		}
		if (exito == 1) {
			writeInfo(numeradorInfo);
		}
	}		
	signal(0);

	result.retorno_u.numero = numero;	
	if (exito == 1) {
		result.cod_ret = 1;
		printf("Vendedor libre obtenido: %d.", numero);
	}
	else {
		result.cod_ret = 2;
		printf("No hay vendedores libres disponibles.");
	}
	
	result.retorno_u.numero = 8;
	result.cod_ret = 1;
	return &result;
}

void *
devolvercliente_2_svc(int *argp, struct svc_req *rqstp)
{
	printf("Devolviendo el cliente: %d.\n", (*argp));
	static char * result;

	initIPC();

	NumeradorInfo* numeradorInfo;
	wait(0);
	{
		numeradorInfo = (NumeradorInfo*)data;
		numeradorInfo->numerosClientes[(*argp)-1] = 0;
		writeInfo(numeradorInfo);
	}		
	signal(0);

	return (void *) &result;
}

void *
devolvervendedor_2_svc(int *argp, struct svc_req *rqstp)
{
	printf("Devolviendo el vendedor: %d.\n", (*argp));
	static char * result;

	initIPC();

	NumeradorInfo* numeradorInfo;
	wait(0);
	{
		numeradorInfo = (NumeradorInfo*)data;
		numeradorInfo->numerosVendedores[(*argp)-1] = 0;
		writeInfo(numeradorInfo);	
	}		
	signal(0);

	return (void *) &result;
}

void *
resetearclientes_2_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;

	printf("Reseteando clientes...\n");

	initIPC();
	NumeradorInfo* numeradorInfo;
	wait(0);
	{
		numeradorInfo = (NumeradorInfo*)data;
		int i;
		for (i = 0; i < MAX_CLIENTES; ++i) {
			numeradorInfo->numerosClientes[i] = 0;
		}

		writeInfo(numeradorInfo);

	}		
	signal(0);

	return (void *) &result;
}

void *
resetearvendedores_2_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;

	printf("Reseteando vendedores...\n");

	initIPC();
	NumeradorInfo* numeradorInfo;
	wait(0);
	{
		numeradorInfo = (NumeradorInfo*)data;
		int i;
		for (i = 0; i < MAX_CLIENTES; ++i) {
			numeradorInfo->numerosVendedores[i] = 0;
		}

		writeInfo(numeradorInfo);

	}		
	signal(0);

	return (void *) &result;
}

retorno *
listadoclientes_2_svc(void *argp, struct svc_req *rqstp)
{
	static retorno  result;

	initIPC();

	NumeradorInfo* numeradorInfo;
	wait(0);
	{
		numeradorInfo = (NumeradorInfo*)data;
		strcpy (result.retorno_u.informacion, numeradorInfo->numerosClientes); /* asignacion de string segun c */
	}		
	signal(0);

	result.cod_ret = 1;
	return &result;
}

retorno *
listadovendedores_2_svc(void *argp, struct svc_req *rqstp)
{
	static retorno  result;

	initIPC();
	NumeradorInfo* numeradorInfo;
	wait(0);
	{
		numeradorInfo = (NumeradorInfo*)data;
		strcpy (result.retorno_u.informacion, numeradorInfo->numerosVendedores); /* asignacion de string segun c */
	}		
	signal(0);

	result.cod_ret = 1;
	return &result;
}

/* IPC */

void initIPC() {
	if (data == NULL) getSharedMemory(DIRECTORY_NUM, ID_SHMEM_NUMERADOR);
	if (semaphoreId == 0) getSemaphore(DIRECTORY_NUM, ID_SEMCONTROL_NUMERADOR, 1);
}

/* Shared Memory Methods */

int getSharedMemory(char *fileName, int id) {
	int result = getShMemId(fileName, id, 0666);
	if (result < 0) return -1;
	return attachMemory();
}

int getShMemId(char *fileName, int id, int flags) {
	char buffer[255];
	key_t clave = ftok (fileName, id);
	if ( clave == -1 ) {
		strcpy(buffer, "Error en SharedMemory - ftok:");
		strcat(buffer, strerror(errno));	
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}

	shMemId = shmget( clave, sizeof(NumeradorInfo) , flags);
	if ( id == -1 ) {
		strcpy(buffer, "Error en SharedMemory - shmget:");
		strcat(buffer, strerror(errno));
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}
	return 0;
}

int attachMemory() {
	// Me attacho a la memoria dejando al SO que elija donde ubicar la memoria 
	// (atributo en NULL)y para lectura/escritura (atributo en 0)
	char buffer[255];
	void *shmaddr = shmat(shMemId, (void *)NULL, 0);
	if (shmaddr == (void *)-1) {
		strcpy(buffer, "Error en Shared Memory - shmat:");
		strcat(buffer, strerror(errno));
		strcat(buffer, "\n");	
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}
	data = shmaddr;
	return 0;
}

void writeInfo(NumeradorInfo* dato) {
	/* CUIDADO
	 * data = direccion de memoria compartida
	 * dato = dato a guardar en la memoria compartida */
	NumeradorInfo *dir = (NumeradorInfo*)data;

	int i = 0;
	for (i = 0; i < MAX_CLIENTES; ++i) {
		dir->numerosClientes[i] = dato->numerosClientes[i];
	}
	for (i = 0; i < MAX_VENDEDORES; ++i) {
		dir->numerosVendedores[i] = dato->numerosVendedores[i];
	}
}

/* Semaphore Methods */

int getSemaphore(char *fileName, int id, int qty) {
	int result = getSemaphoreId(fileName, id, qty, 0666);
	return result;
}

int getSemaphoreId(char *fileName, int id, int qty, int flags)
{ 
	char buffer[255];
	key_t clave = ftok (fileName, id);
	if ( clave == -1 ) {
		strcpy(buffer, "Error en Semaphore - ftok:");
		strcat(buffer, strerror(errno));	
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}

	semaphoreId =  semget( clave, qty, flags);
	if ( semaphoreId == -1 ) {
		strcpy(buffer, "Error en Semaphore - semget:");
		strcat(buffer, strerror(errno));
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}
	return 0;
}

int wait(int numSem)
{	
	struct sembuf oper;
	oper.sem_num = numSem;
	oper.sem_op = -1;
	return (semop(semaphoreId, &oper, 1));
}

int signal(int numSem)
{
	struct sembuf oper;
	oper.sem_num = numSem;
	oper.sem_op = 1;
	oper.sem_flg = 0;
	return (semop(semaphoreId, &oper, 1));
} 
