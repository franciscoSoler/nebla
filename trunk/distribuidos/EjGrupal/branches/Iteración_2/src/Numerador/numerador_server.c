/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "numerador.h"

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <unistd.h>
#include <errno.h>

#include "commonNumerador.h"

int semaphoreCliente = 0;
int shMemCliente = 0;
void* dataCliente = NULL;

int semaphoreVendedor = 0;
int shMemVendedor = 0;
void* dataVendedor = NULL;

void initIPCCliente();
void initIPCVendedor();

/* Shared Memory */
int getShMemId(size_t tam, char *fileName, int id, int flags);
int getVendedoresSharedMemory(char *fileName, int id);
int getClientSharedMemory(char *fileName, int id);
int attachMemory(void *data, int shMemId);

/* Semaphore */
int getSemaphoreId(int *semaphoreId, char *fileName, int id, int qty, int flags);
int getSemaphore(int *semaphoreId, char *fileName, int id, int qty);
int wait(int semaphoreId, int numSem);
int signal(int semaphoreId, int numSem);

int obtenerVendedorLibre () {
    int numeroVendedor = 0;
    int exito = 0;
    int i = 0;
    
    VendedoresInfo *vendedoresInfo;
    
    initIPCVendedor();
    
    wait(semaphoreVendedor, 0);
    {
        vendedoresInfo = (VendedoresInfo*)dataVendedor;
        
        while ((exito == 0) && (i < MAX_VENDEDORES)) {
            printf("Verificando vendedor numero: %d: %d.\n",i+1, vendedoresInfo->idVendedores[i]);
            if (vendedoresInfo->idVendedores[i] == LIBRE) {
                printf("Vendedor libre: %d.\n",i+1);
                numeroVendedor = i+1;
                exito = 1;
                vendedoresInfo->idVendedores[i] = OCUPADO;
            }
            ++i;
	}
	
	/*if (exito == 1) {
            VendedoresInfo *dir = (VendedoresInfo*)dataVendedor;
            memcpy(dir, vendedoresInfo, sizeof(VendedoresInfo));
	}*/
    }
    signal(semaphoreVendedor, 0);

    return numeroVendedor;
}

/* CLIENTE */

retornoCliente *
obteneridcliente_1_svc(void *argp, struct svc_req *rqstp)
{
    static retornoCliente result;
    
    ClientesInfo* clientesInfo;
    int numeroCliente = 0;
    char exito = 0;
    int i = 0;
    
    int numeroVendedor = obtenerVendedorLibre();

    if (numeroVendedor == 0) {
        result.retornoCliente_u.retorno.idVendedorLibre = 0;
        result.retornoCliente_u.retorno.idCliente = 0;
        result.cod_ret = 2;
        return &result;
    }
    
    initIPCCliente();
    printf("Intentando obtener un cliente libre.\n");
    
    wait(semaphoreCliente, 0);
    {
        clientesInfo = (ClientesInfo*)dataCliente;
        while ((exito == 0) && (i < MAX_CLIENTES)) {
            printf("Verificando cliente numero: %d: %d.\n",i+1, clientesInfo->idClientes[i]);
            if (clientesInfo->idClientes[i] == DESASIGNADO) {
                printf("Cliente libre: %d.\n",i+1);
                numeroCliente = i+1;
                exito = 1;
                clientesInfo->idClientes[i] = ASIGNADO;
                /*ClientesInfo *dir = (ClientesInfo*)dataClientes;
                memcpy(dir, clientesInfo, sizeof(ClientesInfo));*/
            }
            ++i;
        }
    }
    signal(semaphoreCliente, 0);
    
    result.retornoCliente_u.retorno.idVendedorLibre = numeroVendedor;
    result.retornoCliente_u.retorno.idCliente = numeroCliente;
    
    if (exito == 1) {
        result.cod_ret = 1;
        printf("Cliente libre obtenido: %d.\n", numeroCliente);
    }
    else {
        result.cod_ret = 2;
	printf("No hay clientes libres disponibles.\n");
    }
    return &result;
}

void *
devolveridcliente_1_svc(int *argp, struct svc_req *rqstp)
{
    static char * result;
    ClientesInfo* clientesInfo;
    
    printf("Devolviendo el cliente: %d.\n", (*argp));
    
    initIPCCliente();
    wait(semaphoreCliente, 0);
    {
        clientesInfo = (ClientesInfo*)dataCliente;
	clientesInfo->idClientes[(*argp)-1] = DESASIGNADO;
        /*ClientesInfo *dir = (ClientesInfo*)dataClientes;
        memcpy(dir, clientesInfo, sizeof(ClientesInfo));*/
    }		
    signal(semaphoreCliente, 0);
    return (void *) &result;
}

void *
resetearclientes_1_svc(void *argp, struct svc_req *rqstp)
{
    static char * result;
    
    ClientesInfo* clientesInfo;
    int i;
    
    printf("Reseteando clientes...\n");
    initIPCCliente();
    wait(semaphoreCliente, 0);
    {
        clientesInfo = (ClientesInfo*)dataCliente;
	for (i = 0; i < MAX_CLIENTES; ++i) {
            clientesInfo->idClientes[i] = DESASIGNADO;
	}
        
        /*ClientesInfo *dir = (ClientesInfo*)dataClientes;
        memcpy(dir, clientesInfo, sizeof(ClientesInfo));*/
    }	
    signal(semaphoreCliente, 0);
    
    return (void *) &result;
}

retornoCliente *
listadoclientes_1_svc(void *argp, struct svc_req *rqstp)
{
    static retornoCliente  result;
    
    ClientesInfo* clienteInfo;
    initIPCCliente();
    wait(semaphoreCliente, 0);
    {
        clienteInfo = (ClientesInfo*)dataCliente;
        memcpy(result.retornoCliente_u.informacion,clienteInfo->idClientes,MAX_CLIENTES * sizeof(EstadoClientes));
    }		
    signal(semaphoreCliente, 0);
    
    result.cod_ret = 1;
    return &result;
}

/* VENDEDOR */

retornoVendedor *
obteneridvendedor_1_svc(void *argp, struct svc_req *rqstp)
{
    static retornoVendedor  result;

    VendedoresInfo* vendedoresInfo;
    int numeroVendedor = 0;
    char exito = 0;
    int i = 0;
    
    initIPCVendedor();
    printf("Intentando obtener un numero de vendedor desasignado.\n");
    
    wait(semaphoreVendedor, 0);
    {
        vendedoresInfo = (VendedoresInfo*)dataVendedor;
        while ((exito == 0) && (i < MAX_VENDEDORES)) {
            printf("Verificando vendedor numero: %d: %d.\n",i+1, vendedoresInfo->idVendedores[i]);
            if (vendedoresInfo->idVendedores[i] == NOASIGNADO) {
                printf("Vendedores libre: %d.\n",i+1);
                numeroVendedor = i+1;
                exito = 1;
                vendedoresInfo->idVendedores[i] = LIBRE;
                /*ClientesInfo *dir = (ClientesInfo*)dataClientes;
                memcpy(dir, clientesInfo, sizeof(ClientesInfo));*/
            }
            ++i;
        }
    }
    signal(semaphoreVendedor, 0);
    
    result.retornoVendedor_u.idVendedor = numeroVendedor;
    
    if (exito == 1) {
        result.cod_ret = 1;
        printf("Vendedor desasignafo obtenido: %d.\n", numeroVendedor);
    }
    else {
        result.cod_ret = 2;
	printf("No hay vendedores desasignados disponibles.\n");
    }

    return &result;
}

void *
vendedorlibre_1_svc(int *argp, struct svc_req *rqstp)
{
    static char * result;
    
    VendedoresInfo* vendedoresInfo;

    initIPCVendedor();
    printf("Liberando vendedor %d.\n",(*argp));
    
    wait(semaphoreVendedor, 0);
    {
        vendedoresInfo = (VendedoresInfo*)dataVendedor;
        vendedoresInfo->idVendedores[(*argp)-1] = LIBRE;
    }
    signal(semaphoreVendedor, 0);
    
    return (void *) &result;
}

void *
devolveridvendedor_1_svc(int *argp, struct svc_req *rqstp)
{
    static char * result;
    
    VendedoresInfo* vendedoresInfo;
   
    initIPCVendedor();
    printf("Devolviendo id vendedor %d.\n",(*argp));
    
    wait(semaphoreVendedor, 0);
    {
        vendedoresInfo = (VendedoresInfo*)dataVendedor;
        vendedoresInfo->idVendedores[(*argp)-1] = NOASIGNADO;
    }
    signal(semaphoreVendedor, 0);

    return (void *) &result;
}

void *
resetearvendedores_1_svc(void *argp, struct svc_req *rqstp)
{
    static char * result;

    VendedoresInfo* vendedoresInfo;
    int i;
    
    printf("Reseteando vendedores...\n");
    initIPCVendedor();
    wait(semaphoreVendedor, 0);
    {
        vendedoresInfo = (VendedoresInfo*)dataVendedor;
	for (i = 0; i < MAX_VENDEDORES; ++i) {
            vendedoresInfo->idVendedores[i] = NOASIGNADO;
	}
    }	
    signal(semaphoreVendedor, 0);
    return (void *) &result;
}

retornoVendedor *
listadovendedores_1_svc(void *argp, struct svc_req *rqstp)
{
    static retornoVendedor  result;
        
    VendedoresInfo* vendedoresInfo;
    initIPCVendedor();
    wait(semaphoreVendedor, 0);
    {
        vendedoresInfo = (VendedoresInfo*)dataVendedor;
        memcpy(result.retornoVendedor_u.informacion,vendedoresInfo->idVendedores,MAX_VENDEDORES * sizeof(EstadoVendedores));
    }		
    signal(semaphoreVendedor, 0);
    
    result.cod_ret = 1;
    return &result;
}

/* IPC */

void initIPCCliente() {
	if (dataCliente == NULL) getClientSharedMemory( DIRECTORY_NUMERADOR, ID_NUMERADOR_CLIENTES);
	if (semaphoreCliente == 0) getSemaphore(&semaphoreCliente, DIRECTORY_NUMERADOR, ID_NUMERADOR_CLIENTES, 1);
}

void initIPCVendedor() {
	if (dataVendedor == NULL) getVendedoresSharedMemory(DIRECTORY_NUMERADOR, ID_NUMERADOR_VENDEDORES);
	if (semaphoreVendedor == 0) getSemaphore(&semaphoreVendedor, DIRECTORY_NUMERADOR, ID_NUMERADOR_VENDEDORES, 1);
}

/* Shared Memory Methods */
int getClientSharedMemory(char *fileName, int id) {
	int result = getShMemId(sizeof(ClientesInfo),fileName, id, 0666);
	if (result < 0) return -1;
	return attachMemory(dataCliente, result);
}

int getVendedoresSharedMemory(char *fileName, int id) {
	int result = getShMemId(sizeof(VendedoresInfo),fileName, id, 0666);
	if (result < 0) return -1;
	return attachMemory(dataVendedor, result);
}

int getShMemId(size_t tam, char *fileName, int id, int flags) {
	char buffer[255];
	int shMemId;
        key_t clave = ftok (fileName, id);
	if ( clave == -1 ) {
		strcpy(buffer, "Error en SharedMemory - ftok:");
		strcat(buffer, strerror(errno));	
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}

	shMemId = shmget( clave, tam , flags);
	if ( shMemId == -1 ) {
		strcpy(buffer, "Error en SharedMemory - shmget:");
		strcat(buffer, strerror(errno));
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}
	return shMemId;
}

int attachMemory(void *data, int shMemId) {
	/* Me attacho a la memoria dejando al SO que elija donde ubicar la memoria 
	 * (atributo en NULL)y para lectura/escritura (atributo en 0) */
	char buffer[255];
	void *shmaddr = shmat(shMemId, (void *)NULL, 0);
	if (shmaddr == (void *)-1) {
		strcpy(buffer, "Error en Shared Memory - shmat:");
		strcat(buffer, strerror(errno));
		strcat(buffer, "\n");	
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}
	data = shmaddr;
	return 0;
}

/* Semaphore Methods */
int getSemaphore(int *semaphoreId, char *fileName, int id, int qty) {
	int result = getSemaphoreId(semaphoreId, fileName, id, qty, 0666);
	return result;
}

int getSemaphoreId(int *semaphoreId, char *fileName, int id, int qty, int flags) { 
	char buffer[255];
	key_t clave = ftok (fileName, id);
	if ( clave == -1 ) {
		strcpy(buffer, "Error en Semaphore - ftok:");
		strcat(buffer, strerror(errno));	
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}

	(*semaphoreId) =  semget( clave, qty, flags);
	if ( (*semaphoreId) == -1 ) {
		strcpy(buffer, "Error en Semaphore - semget:");
		strcat(buffer, strerror(errno));
		strcat(buffer, "\n");
		write(fileno(stdout), buffer, strlen(buffer)); 
		return -1;
	}
	return 0;
}

int wait(int semaphoreId, int numSem) {	
	struct sembuf oper;
	oper.sem_num = numSem;
	oper.sem_op = -1;
        oper.sem_flg = 0;
	return (semop(semaphoreId, &oper, 1));
}

int signal(int semaphoreId, int numSem) {
	struct sembuf oper;
	oper.sem_num = numSem;
	oper.sem_op = 1;
	oper.sem_flg = 0;
	return (semop(semaphoreId, &oper, 1));
}
